# Clase 9: Prompt Chaining - Encadenar Agentes en Secuencia con LangGraph

## Introducción

El prompt chaining es una técnica de orquestación que permite conectar varios agentes en secuencia para resolver tareas complejas con mayor claridad y control. Cada nodo en la cadena ejecuta una tarea específica usando un LLM y pasa el estado al siguiente nodo.

---

## Conceptos Fundamentales

### ¿Qué es el Prompt Chaining?

El prompt chaining conecta varios nodos en una secuencia donde:
- Cada nodo usa un large language model para una tarea específica
- El modelo no decide el flujo: sigue un orden fijo
- Cada nodo razona localmente sobre su tarea
- El estado se transfiere de un nodo al siguiente

---

## Patrones de Orquestación

### 1. **Secuencial**
Ejecución en orden fijo: Nodo 1 → Nodo 2 → Nodo 3

### 2. **Paralelo**
Varios nodos se ejecutan simultáneamente sin decisiones del modelo

### 3. **Workflows con Decisiones**
El modelo puede elegir qué hacer y cuándo ejecutarlo

### 4. **Patrón Orquestador con Planning**
Planifica y ejecuta solo los nodos necesarios

### 5. **Evaluator**
Ciclo de revisión iterativo hasta que la respuesta sea aceptable

### 6. **Routing**
Decide por qué nodo continuar según condiciones

### 7. **Patrón Agent**
Integra tools y un proceso de reflexión

---

## Cuándo Usar Chaining vs Chain of Thought

### Usar Chain of Thought (Un Solo Prompt)
- Tareas simples donde el modelo puede seguir el plan completo
- Las instrucciones caben bien en un solo prompt
- Se busca optimizar costos (una sola llamada al modelo)
- Modelos razonadores: OpenAI O1 Preview, Gemini 2.5 Thinking, Anthropic con razonamiento

### Usar Chaining (Múltiples Nodos)
- Pasos con alta carga cognitiva
- Prompts muy largos que requieren división
- Integración con servicios externos
- Necesidad de integrar diferentes modelos (LLM + generación de imágenes)
- Claridad arquitectónica y mantenibilidad

### Consideración de Costos
- Cada nodo = una llamada al modelo
- Un solo prompt con razonamiento puede ser más económico
- Equilibrar entre claridad, costo y rendimiento

---

## Implementación en LangGraph

### Flujo Básico

```python
graph = StateGraph(State)

graph.add_node("nodo_1", funcion_nodo_1)
graph.add_node("nodo_2", funcion_nodo_2)
graph.add_node("nodo_3", funcion_nodo_3)

graph.add_edge("nodo_1", "nodo_2")
graph.add_edge("nodo_2", "nodo_3")
graph.add_edge("nodo_3", END)

app = graph.compile()
```

### Alternativa Compacta con Add Sequence

```python
builder.add_sequence([nodo_uno, nodo_dos, nodo_tres])
```

El nombre de la función se usa automáticamente como nombre del nodo.

---

## Caso Práctico: Extractor + Conversation

### Arquitectura

```
INICIO → Extractor → Conversation → FIN
```

### Responsabilidades

**Nodo Extractor:**
- Prepara o extrae datos del estado
- Procesa información antes de la conversación

**Nodo Conversation:**
- Mantiene la interacción con el usuario
- Decide si analizar archivos
- Consulta base de datos vectorial si es necesario
- Genera respuesta final

### Beneficios
- Arquitectura explícita y evolutiva
- Facilita bifurcaciones futuras
- Separación clara de responsabilidades

---

## Ejemplo Real: Social Media Pipeline

### Caso de Uso
Generar contenido para redes sociales desde un documento PDF

### Flujo

```
PDF/Texto → Nodo Generador de Tweet → Nodo Generador de Imagen → Resultado
```

### Implementación

1. **Nodo 1: Generar Tweet**
   - Entrada: Texto largo o PDF
   - Salida: Tweet optimizado

2. **Nodo 2: Generar Imagen**
   - Entrada: Tweet generado
   - Usa modelo de imágenes (DALL·E, Stable Diffusion)
   - Salida: Imagen asociada al tweet

### Por qué Chain es Necesario Aquí
- Chain of thought NO puede generar imágenes
- Se requiere integración de modelos diferentes
- Paso a paso con tecnologías distintas

---

## Workflows vs Agents

### Workflows
**Características:**
- Lógica de acción inmersa en el código
- Pasos, condiciones y herramientas definidas explícitamente
- Control total del flujo
- RAG, APIs, function calls configurados

**Ejemplo:**
1. Preguntar nombre y apellido, esperar respuesta
2. Crear registro en base de datos con function call
3. Solicitar subida de fórmula médica
4. Procesar PDF extraction

### Agents
**Características:**
- Se delega el control al LLM
- El modelo decide qué flujos de acción tomar
- Se proporcionan: instrucciones generales, estado (Graph State), acceso a tools

**Arquitectura ReAct:**
- El agente entra en un bucle
- Usa LLM y tools para llegar al objetivo
- Reflexión y acción iterativa

**Arquitecturas Avanzadas:**
- Múltiples agentes con campos de especialización
- Coordinación entre agentes
- Cada agente único e indispensable en el flujo

---

## Buenas Prácticas

### Visualización
- Usar LangGraph Studio para confirmar el patrón de chain
- Validar conexiones y flujo de estado
- Generar gráficos para documentación

### Ejemplo Educativo vs Producción
**Advertencia:** El ejemplo "generar broma → mejorar broma → añadir twist" funciona didácticamente, pero puede ser innecesario si un modelo razonador puede seguir todo el plan en un solo prompt.

### Arquitectura Evolutiva
- Dejar nodos preparatorios aunque inicialmente no hagan mucho
- Facilita añadir bifurcaciones futuras
- Hace explícita la arquitectura
- Mejora mantenibilidad

---

## Reflexión Final

Al diseñar tu pipeline con LangGraph, considera:

1. **¿Los pasos pueden condensarse en un prompt con razonamiento?**
2. **¿Se requiere integración de múltiples modelos/servicios?**
3. **¿La claridad arquitectónica justifica el costo adicional?**
4. **¿El flujo necesitará evolucionar con más nodos?**

El equilibrio entre chaining y chain of thought depende de tu caso de uso específico, restricciones de costo y necesidades de mantenibilidad.

---

## Recursos

- [LangChain Docs - Overview](https://langchain-ai.github.io/langgraph/tutorials/workflows/)
- [LangGraph Tutorials](https://langchain-ai.github.io/langgraph/)

---

## Preguntas para Reflexionar

- ¿Qué problemas resolverías con un chaining?
- ¿Qué nodos sumarías a tu flujo actual?
- ¿Dónde tiene sentido usar chain of thought vs múltiples nodos?
- ¿Cómo balanceas costo vs claridad en tu arquitectura?