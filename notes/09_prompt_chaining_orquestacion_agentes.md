# Clase 9 ‚Äî Prompt Chaining: Orquestaci√≥n de Agentes en Secuencia

**Objetivo:** Aprender a descomponer tareas complejas en **nodos especializados** que trabajan en secuencia, usando **LangGraph** para crear flujos predecibles y mantenibles.

---

## üß† ¬øQu√© problema resuelve?
Cuando las tareas son complejas, un solo prompt puede fallar o volverse dif√≠cil de mantener.

- **Problema**: Intentar resolver todo en un solo prompt gigante sobrecarga al LLM, reduce precisi√≥n y dificulta el debugging.
- **Soluci√≥n con Prompt Chaining**: Dividir el trabajo en **m√∫ltiples nodos especializados** que trabajan en secuencia, cada uno enfocado en una tarea espec√≠fica.
- **Analog√≠a**: Como cocinar una cena completa siguiendo un plan paso a paso (preparar ingredientes ‚Üí cocinar ‚Üí emplatar) en lugar de hacer todo simult√°neamente.
- **Beneficio clave**: Mayor control del flujo, especializaci√≥n de tareas, facilidad de debugging y arquitectura evolutiva.

El prompt chaining transforma procesos complejos en pipelines estructurados y predecibles.

---

## üîë Ideas clave
Conceptos fundamentales del prompt chaining y su arquitectura.

- **Prompt Chaining**: Patr√≥n de dise√±o donde conectamos varios nodos de procesamiento en secuencia, cada uno especializado en una tarea espec√≠fica.
- **Flujo t√≠pico**: `[Input] ‚Üí [Nodo 1] ‚Üí [Nodo 2] ‚Üí [Nodo 3] ‚Üí [Output]` donde cada nodo es un especialista.
- **Especializaci√≥n**: Cada nodo tiene una responsabilidad √∫nica y bien definida (ej. traducir, analizar, resumir).
- **Estado compartido**: La informaci√≥n fluye entre nodos a trav√©s del estado del grafo (como vimos en Clase 4).
- **Control expl√≠cito**: El flujo est√° definido por el c√≥digo, no por decisiones del modelo (a diferencia de agentes aut√≥nomos).
- **Razonamiento local**: Cada LLM se enfoca solo en su tarea, reduciendo carga cognitiva y mejorando precisi√≥n.

Esta arquitectura permite construir sistemas complejos de forma modular y mantenible.

---

## üè≠ Patrones de Orquestaci√≥n
Diferentes arquitecturas para organizar nodos seg√∫n las necesidades del problema.

### 1. üîó Patr√≥n Secuencial
**Flujo:** `Nodo A ‚Üí Nodo B ‚Üí Nodo C` (lineal y predecible)

**Ejemplo pr√°ctico:**
```python
# Pipeline de an√°lisis de texto
Entrada: "Texto largo en ingl√©s"
‚Üí Nodo 1: Traductor (ingl√©s ‚Üí espa√±ol)
‚Üí Nodo 2: Analizador de sentimiento
‚Üí Nodo 3: Generador de resumen
Salida: "Resumen en espa√±ol con an√°lisis de sentimiento"
```

**¬øCu√°ndo usarlo?**
- Cada paso depende del resultado del anterior
- Proceso claro y lineal sin bifurcaciones
- Transformaci√≥n progresiva de datos (como un pipeline de producci√≥n)

### 2. ‚öñÔ∏è Patr√≥n Paralelo
**Flujo:** `Input ‚Üí [Nodo A | Nodo B | Nodo C] ‚Üí Consolidador` (ejecuci√≥n simult√°nea)

**Ejemplo pr√°ctico:**
```python
# An√°lisis multi-perspectiva de un producto
Entrada: "Rese√±a de producto"
‚Üí Nodo A: An√°lisis t√©cnico (en paralelo)
‚Üí Nodo B: An√°lisis de usabilidad (en paralelo)
‚Üí Nodo C: An√°lisis de precio (en paralelo)
‚Üí Consolidador: Combina resultados en informe completo
```

**Ventajas:**
- ‚ö° **Mayor velocidad**: Ejecuci√≥n simult√°nea reduce tiempo total
- üéØ **M√∫ltiples perspectivas**: Diferentes an√°lisis del mismo input
- üîÑ **Redundancia**: Mayor confiabilidad al tener m√∫ltiples validaciones

### 3. üßæ Patr√≥n Condicional (Routing)
**Flujo:** Decisiones basadas en condiciones que determinan el siguiente nodo

**Ejemplo pr√°ctico:**
```python
# Clasificador de consultas de soporte
Entrada: "Consulta del cliente"
‚Üí Clasificador (analiza tipo de consulta)
  ‚îÇ
  ‚îú‚îÄ Si es "T√©cnico" ‚Üí Nodo Soporte T√©cnico
  ‚îú‚îÄ Si es "Facturaci√≥n" ‚Üí Nodo Finanzas
  ‚îî‚îÄ Si es "General" ‚Üí Nodo Atenci√≥n al Cliente
```

**¬øCu√°ndo usarlo?**
- Diferentes tipos de input requieren procesamiento diferente
- Sistemas de clasificaci√≥n y enrutamiento
- Workflows adaptativos seg√∫n contexto

### 4. ü§ñ Patr√≥n Planificador (Planning)
**Flujo:** Un nodo "maestro" decide din√°micamente qu√© nodos ejecutar

**Ejemplo pr√°ctico:**
```python
# Sistema de investigaci√≥n inteligente
Pregunta: "¬øC√≥mo afecta el cambio clim√°tico a la agricultura?"
‚Üí Planificador analiza y decide:
  - ‚úÖ Necesita: B√∫squeda web + An√°lisis de papers + S√≠ntesis
  - ‚ùå No necesita: Generaci√≥n de im√°genes + Traducci√≥n
‚Üí Ejecuta solo los nodos necesarios
```

**Ventajas:**
- Optimiza recursos ejecutando solo lo necesario
- Adaptable a diferentes tipos de consultas
- Reduce costos al evitar llamadas innecesarias

### 5. üîç Patr√≥n Evaluador (Critic Loop)
**Flujo c√≠clico:** Generar ‚Üí Evaluar ‚Üí Mejorar ‚Üí Repetir hasta cumplir criterios

**Ejemplo pr√°ctico:**
```python
# Generador de contenido con control de calidad
1. Generador: Crea art√≠culo inicial
2. Evaluador: Revisa criterios (claridad, tono, longitud)
3. Si NO cumple: Genera feedback espec√≠fico ‚Üí vuelve al paso 1
4. Si S√ç cumple: Art√≠culo aprobado ‚Üí FIN
```

**¬øCu√°ndo usarlo?**
- Necesitas garantizar calidad del output
- Iteraci√≥n hasta cumplir est√°ndares espec√≠ficos
- Mejora progresiva basada en feedback

### 6. ü¶Ä Patr√≥n Agente (ReAct)
**Flujo aut√≥nomo:** El LLM decide qu√© herramientas usar y cu√°ndo

**Caracter√≠sticas:**
- **Razonamiento + Acci√≥n**: El agente piensa y act√∫a iterativamente
- **Autonom√≠a**: Decide qu√© herramientas usar seg√∫n el contexto
- **Menos control**: El flujo no est√° predefinido, el LLM tiene libertad
- **Reflexi√≥n iterativa**: Eval√∫a resultados y ajusta estrategia

**¬øCu√°ndo usarlo?**
- Tareas abiertas sin flujo predefinido
- Necesitas que el agente explore soluciones
- Priorizas flexibilidad sobre control estricto

> **Nota**: Este patr√≥n se ver√° en detalle en clases posteriores sobre agentes aut√≥nomos.

---

## ‚öñÔ∏è Cu√°ndo usar Chaining vs Chain of Thought
Decisi√≥n cr√≠tica: ¬øUn solo prompt con razonamiento o m√∫ltiples nodos especializados?

### Usar Chain of Thought (Un Solo Prompt)
**Mejor para:**
- ‚úÖ Tareas simples donde el modelo puede seguir todo el plan
- ‚úÖ Instrucciones que caben c√≥modamente en un prompt
- ‚úÖ Optimizar costos (una sola llamada al LLM)
- ‚úÖ Modelos razonadores avanzados (OpenAI O1, Gemini 2.0 Flash Thinking, Claude con extended thinking)

**Ejemplo:** "Analiza este texto, identifica el sentimiento y genera un resumen" ‚Üí Un solo prompt bien estructurado.

### Usar Chaining (M√∫ltiples Nodos)
**Mejor para:**
- ‚úÖ Pasos con alta carga cognitiva que necesitan enfoque dedicado
- ‚úÖ Prompts muy largos que requieren divisi√≥n para claridad
- ‚úÖ Integraci√≥n con servicios externos (APIs, bases de datos)
- ‚úÖ Combinar diferentes modelos (LLM + generaci√≥n de im√°genes + TTS)
- ‚úÖ Arquitectura evolutiva que crecer√° con el tiempo
- ‚úÖ Debugging y mantenibilidad a largo plazo

**Ejemplo:** "Extrae datos de PDF ‚Üí Genera tweet ‚Üí Crea imagen para el tweet" ‚Üí Requiere m√∫ltiples tecnolog√≠as.

### üí∞ Consideraci√≥n de Costos
- **Chaining**: Cada nodo = una llamada al modelo ‚Üí Mayor costo
- **Chain of Thought**: Una sola llamada ‚Üí M√°s econ√≥mico
- **Balance**: Eval√∫a claridad arquitect√≥nica vs costo seg√∫n tu caso de uso

---

## ‚öôÔ∏è Implementaci√≥n en LangGraph
C√≥mo construir flujos secuenciales con LangGraph (recordando conceptos de Clase 4).

### M√©todo 1: Construcci√≥n Manual
```python
from langgraph.graph import StateGraph, END
from typing import TypedDict

class State(TypedDict):
    input: str
    result: str

# Definir funciones de nodos
def nodo_1(state: State) -> State:
    # Procesar y retornar estado actualizado
    return {"result": f"Procesado por nodo 1: {state['input']}"}

def nodo_2(state: State) -> State:
    return {"result": f"{state['result']} + nodo 2"}

def nodo_3(state: State) -> State:
    return {"result": f"{state['result']} + nodo 3"}

# Construir grafo
graph = StateGraph(State)
graph.add_node("nodo_1", nodo_1)
graph.add_node("nodo_2", nodo_2)
graph.add_node("nodo_3", nodo_3)

# Conectar en secuencia
graph.set_entry_point("nodo_1")
graph.add_edge("nodo_1", "nodo_2")
graph.add_edge("nodo_2", "nodo_3")
graph.add_edge("nodo_3", END)

app = graph.compile()
```

### M√©todo 2: Atajo con `add_sequence`
```python
# Forma compacta para flujos lineales
builder.add_sequence([nodo_1, nodo_2, nodo_3])
```

> **Nota**: El nombre de la funci√≥n se usa autom√°ticamente como nombre del nodo. √ötil para prototipos r√°pidos.

---

## üíº Caso Pr√°ctico 1: Pipeline Extractor + Conversation
Ejemplo real de c√≥mo estructurar un agente conversacional con preparaci√≥n de datos.

### Arquitectura
```
INICIO ‚Üí Extractor ‚Üí Conversation ‚Üí FIN
```

### Responsabilidades de cada nodo

**Nodo Extractor:**
- Prepara o extrae datos del estado inicial
- Procesa archivos o documentos si est√°n presentes
- Enriquece el estado con informaci√≥n estructurada
- Ejemplo: Extraer texto de PDF antes de conversar

**Nodo Conversation:**
- Mantiene la interacci√≥n con el usuario
- Decide si necesita consultar RAG (como vimos en Clase 8)
- Usa el estado enriquecido por el extractor
- Genera respuesta final contextualizada

### Beneficios de esta arquitectura
- ‚úÖ **Separaci√≥n de responsabilidades**: Extracci√≥n vs conversaci√≥n
- ‚úÖ **Evolutiva**: F√°cil agregar nodos entre extractor y conversation
- ‚úÖ **Debugging simplificado**: Puedes inspeccionar estado despu√©s de cada nodo
- ‚úÖ **Reutilizable**: El extractor puede usarse en otros flujos

---

## üíº Caso Pr√°ctico 2: Pipeline de Social Media
Ejemplo que demuestra por qu√© el chaining es necesario para integrar m√∫ltiples tecnolog√≠as.

### Caso de Uso
Generar contenido completo para redes sociales (texto + imagen) desde un documento PDF.

### Arquitectura
```
PDF/Texto ‚Üí Generador de Tweet ‚Üí Generador de Imagen ‚Üí Output Final
```

### Implementaci√≥n paso a paso

**Nodo 1: Generador de Tweet**
- **Entrada**: Texto largo extra√≠do del PDF
- **Proceso**: LLM resume y optimiza para Twitter (280 caracteres)
- **Salida**: Tweet optimizado guardado en estado

**Nodo 2: Generador de Imagen**
- **Entrada**: Tweet del nodo anterior
- **Proceso**: Usa modelo de im√°genes (DALL¬∑E, Stable Diffusion)
- **Prompt para imagen**: Basado en el contenido del tweet
- **Salida**: URL o archivo de imagen generada

**Nodo 3: Compositor Final**
- **Entrada**: Tweet + imagen
- **Salida**: Post completo listo para publicar

### ¬øPor qu√© Chaining es necesario aqu√≠?
- ‚ùå **Chain of Thought NO funciona**: Un LLM no puede generar im√°genes
- ‚úÖ **Requiere m√∫ltiples modelos**: LLM (texto) + modelo de difusi√≥n (imagen)
- ‚úÖ **Tecnolog√≠as diferentes**: Cada paso usa APIs distintas
- ‚úÖ **Dependencias claras**: La imagen depende del tweet generado

---

## üîÄ Workflows vs Agents: Diferencias Clave
Entender cu√°ndo usar control expl√≠cito (workflows) vs autonom√≠a (agents).

### Workflows (Control Expl√≠cito)
**Caracter√≠sticas:**
- ‚úÖ L√≥gica de acci√≥n definida en el c√≥digo
- ‚úÖ Pasos, condiciones y herramientas expl√≠citas
- ‚úÖ Control total del flujo de ejecuci√≥n
- ‚úÖ Predecible y determinista
- ‚úÖ RAG, APIs, function calls pre-configurados

**Ejemplo de flujo m√©dico:**
```python
1. Preguntar nombre y apellido ‚Üí esperar respuesta
2. Crear registro en BD con function call
3. Solicitar subida de f√≥rmula m√©dica ‚Üí esperar archivo
4. Procesar PDF con extraction
5. Generar resumen m√©dico
```

**¬øCu√°ndo usar?**
- Procesos regulados o cr√≠ticos (finanzas, salud)
- Necesitas garantizar pasos espec√≠ficos
- Debugging y auditor√≠a son prioritarios

### Agents (Autonom√≠a del LLM)
**Caracter√≠sticas:**
- ‚úÖ Se delega control al LLM
- ‚úÖ El modelo decide qu√© herramientas usar y cu√°ndo
- ‚úÖ Proporciones: instrucciones generales + estado + tools
- ‚úÖ Flexible y adaptable
- ‚úÖ Arquitectura ReAct (Razonamiento + Acci√≥n)

**Ejemplo de agente investigador:**
```python
Objetivo: "Investiga sobre energ√≠a solar"
‚Üí Agente decide:
  1. Buscar en web
  2. Analizar papers relevantes
  3. Consultar base de datos
  4. Sintetizar hallazgos
‚Üí El orden y herramientas no est√°n predefinidos
```

**¬øCu√°ndo usar?**
- Tareas abiertas sin flujo fijo
- Necesitas exploraci√≥n y creatividad
- El contexto determina las acciones necesarias

> **Nota**: Puedes combinar ambos enfoques (workflow con nodos agente para tareas espec√≠ficas).

---

## ‚úÖ Buenas Pr√°cticas
Recomendaciones para dise√±ar y mantener sistemas con prompt chaining.

### 1. Visualizaci√≥n del Grafo
- **Usa LangGraph Studio**: Visualiza el flujo completo de tu chain
- **Valida conexiones**: Aseg√∫rate de que todos los edges est√©n correctos
- **Documenta con diagramas**: Genera gr√°ficos para tu equipo
- **Inspecciona estado**: Revisa c√≥mo fluye la informaci√≥n entre nodos

### 2. Evita Over-Engineering
**‚ö†Ô∏è Advertencia**: No todo necesita m√∫ltiples nodos.

**Ejemplo educativo vs real:**
- ‚ùå "Generar broma ‚Üí mejorar broma ‚Üí a√±adir twist" ‚Üí Innecesario con modelos razonadores
- ‚úÖ "Extraer datos ‚Üí Consultar API ‚Üí Generar reporte" ‚Üí Justificado por integraci√≥n de servicios

**Pregunta clave:** ¬øUn modelo razonador puede hacer esto en un solo prompt?

### 3. Arquitectura Evolutiva
- **Nodos preparatorios**: D√©jalos aunque inicialmente no hagan mucho
- **Facilita bifurcaciones**: Estructura que permite agregar nodos f√°cilmente
- **Expl√≠cita**: Hace visible la arquitectura del sistema
- **Mantenible**: Cambios futuros son m√°s simples

**Ejemplo:**
```python
# Hoy: Extractor ‚Üí Conversation
# Ma√±ana: Extractor ‚Üí Validator ‚Üí Enricher ‚Üí Conversation
# La estructura inicial facilita la evoluci√≥n
```

---

## üí≠ Reflexi√≥n Final

Al dise√±ar tu pipeline con LangGraph, hazte estas preguntas:

1. **¬øLos pasos pueden condensarse en un prompt con razonamiento?** ‚Üí Considera Chain of Thought
2. **¬øSe requiere integraci√≥n de m√∫ltiples modelos/servicios?** ‚Üí Usa Chaining
3. **¬øLa claridad arquitect√≥nica justifica el costo adicional?** ‚Üí Eval√∫a trade-offs
4. **¬øEl flujo necesitar√° evolucionar con m√°s nodos?** ‚Üí Dise√±a arquitectura evolutiva

El equilibrio entre chaining y chain of thought depende de tu caso de uso espec√≠fico, restricciones de costo y necesidades de mantenibilidad.

---

## üìö Recursos

- [LangGraph Workflows - Documentaci√≥n Oficial](https://langchain-ai.github.io/langgraph/tutorials/workflows/)
- [LangGraph Tutorials](https://langchain-ai.github.io/langgraph/)
- [Prompt Chaining Best Practices](https://www.promptingguide.ai/techniques/prompt_chaining)

---

## ü§î Preguntas para Reflexionar

- ¬øQu√© problemas de tu proyecto actual resolver√≠as con chaining?
- ¬øQu√© nodos agregar√≠as a tu flujo para hacerlo m√°s robusto?
- ¬øD√≥nde tiene sentido usar chain of thought vs m√∫ltiples nodos en tu caso?
- ¬øC√≥mo balanceas costo vs claridad arquitect√≥nica en tu sistema?
- ¬øTu arquitectura actual permite evolucionar f√°cilmente?